[
{
	"uri": "/",
	"title": "Deploying a NodeJs Application on AWS using Terraform",
	"tags": [],
	"description": "",
	"content": "Deploying a NodeJs Application on AWS using Terraform Overall In this lab, you will learn how to deploy a scalable NodeJS web application on Amazon Web Services (AWS) using Terraform, a powerful Infrastructure as Code (IaC) tool. This lab provides a practical approach to building a cloud-based architecture from scratch, leveraging Terraform to automate the deployment and management of cloud infrastructure.\nContent Introduction Preparation Coding Manage session logs Port Forwarding Clean up resources "
},
{
	"uri": "/5-alb-route53/5-1-alb/",
	"title": "Create Application Load Balancer",
	"tags": [],
	"description": "",
	"content": "Set up files In load_balancers folder, we create three respectively files, named main.tf, variables.tf, outputs.tf\nload_balancers ├── main.tf ├── outputs.tf └── variables.tf Variables A load balancer will need EC2 instances’s information, VPC’s id. Here we will put it in two subnets, attach with a security group:\nvariable \u0026#34;vpc_id\u0026#34; { type = string } variable \u0026#34;instances\u0026#34; { } variable \u0026#34;subnets\u0026#34; { } variable \u0026#34;security_group_id\u0026#34; { } Main Firstly, we create load balancer’s target group and attach it with our EC2 instances: resource \u0026#34;aws_alb_target_group\u0026#34; \u0026#34;web_servers\u0026#34; { name = \u0026#34;web-servers\u0026#34; port = 5000 protocol = \u0026#34;HTTP\u0026#34; vpc_id = var.vpc_id slow_start = 0 load_balancing_algorithm_type = \u0026#34;round_robin\u0026#34; } resource \u0026#34;aws_lb_target_group_attachment\u0026#34; \u0026#34;main\u0026#34; { for_each = var.instances target_group_arn = aws_alb_target_group.web_servers.arn target_id = each.value.id } After that, create the load balancer: resource \u0026#34;aws_lb\u0026#34; \u0026#34;main\u0026#34; { name = \u0026#34;web\u0026#34; internal = false load_balancer_type = \u0026#34;application\u0026#34; security_groups = [var.security_group_id] subnets = var.subnets enable_deletion_protection = false tags = { Name = \u0026#34;web\u0026#34; } } Finally, a load balancer needs a listener to forward traffic to its target group: resource \u0026#34;aws_lb_listener\u0026#34; \u0026#34;main\u0026#34; { load_balancer_arn = aws_lb.main.arn port = 80 protocol = \u0026#34;HTTP\u0026#34; default_action { type = \u0026#34;forward\u0026#34; target_group_arn = aws_alb_target_group.web_servers.arn } } Output We need dns name and zone id of the Application Load Balancer:\noutput \u0026#34;dns_name\u0026#34; { value = aws_lb.main.dns_name } output \u0026#34;zone_id\u0026#34; { value = aws_lb.main.zone_id } "
},
{
	"uri": "/4-computing-storage/4.1-storage/",
	"title": "Create RDS instance",
	"tags": [],
	"description": "",
	"content": "In the databases folder, we will create three files and name them respectively as main.tf, variables.tf, outputs.tf\ndatabases\r├── main.tf\r├── outputs.tf\r└── variables.tf Variables For the databases module, we need to provide these variables:\nvariable \u0026#34;rds_username\u0026#34; {\rtype = string\rsensitive = true\r}\rvariable \u0026#34;rds_password\u0026#34; {\rtype = string\rsensitive = true\r}\rvariable \u0026#34;vpc_id\u0026#34; {\r}\rvariable \u0026#34;first_subnet_id\u0026#34; {\r}\rvariable \u0026#34;second_subnet_id\u0026#34; {\r}\rvariable \u0026#34;security_group_id\u0026#34; {\r} Main Subnet group: An Amazon RDS instance needs a subnet group. A DB subnet group is a collection of subnets (typically private) that you create in a VPC and that you then designate for your DB instances. Because we will be using a multi-AZ RDS instance, we will create a subnet group that has two subnets: resource \u0026#34;aws_db_subnet_group\u0026#34; \u0026#34;main\u0026#34; {\rname = \u0026#34;subnet-group\u0026#34;\rsubnet_ids = [var.first_subnet_id, var.second_subnet_id]\rtags = {\rName = \u0026#34;subnet-group\u0026#34;\r}\r} RDS instance: After we have a subnet group, we can create an RDS instance: resource \u0026#34;aws_db_instance\u0026#34; \u0026#34;main\u0026#34; {\rallocated_storage = 20\rstorage_type = \u0026#34;gp2\u0026#34;\rengine = \u0026#34;mysql\u0026#34;\rengine_version = \u0026#34;8.0\u0026#34;\rinstance_class = \u0026#34;db.t3.micro\u0026#34;\ridentifier = \u0026#34;main\u0026#34;\rusername = var.rds_username\rpassword = var.rds_password\rvpc_security_group_ids = [var.security_group_id]\rdb_name = \u0026#34;first_cloud_users\u0026#34;\rmulti_az = true\rtags = {\rName = \u0026#34;workshop-1-db\u0026#34;\r}\rdb_subnet_group_name = aws_db_subnet_group.main.name\r} Output This module will take out the database’s host:\noutput \u0026#34;rds_host\u0026#34; {\rvalue = aws_db_instance.main.address\r} "
},
{
	"uri": "/2-prerequiste/2.1-iamuser/",
	"title": "IAM User",
	"tags": [],
	"description": "",
	"content": "Create IAM User You will create IAM User for this workshop through AWS console home page.\nGo to Users section in IAM Click Create user User name: WorkshopUser Click Next Select Attach policies directly Now we will provide some permissions for this IAM user:\nAmazonRoute53FullAccess AmazonRDSFullAccess AmazonRDSFullAccess AmazonEC2FullAccess Click Next Check permissions and click Create user Create Access key After we created access key, we will Download.csv file and Done "
},
{
	"uri": "/1-introduce/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Objective By the end of this lab, you will be able to:\nUnderstand the core concepts of Terraform and AWS infrastructure. Write Terraform configurations to provision and manage cloud resources. Deploy a NodeJS web application on AWS using a robust and scalable architecture. Architecture Overview Here\u0026rsquo;s a brief overview of the components involved:\nDomain Management: DNS management is handled by an AWS Route 53 Hosted Zone, ensuring that traffic is directed to the correct resources. Network Design: The AWS infrastructure is built within a Virtual Private Cloud (VPC) that spans multiple Availability Zones for fault tolerance. The VPC includes both public and private subnets: Public Subnets: Contain EC2 instances configured to serve web traffic. Private Subnets: Host the primary and secondary databases, ensuring data security and isolation from the internet. Load Balancing: An Application Load Balancer (ALB) distributes incoming web traffic across multiple EC2 instances, providing high availability and redundancy. Internet Access: An Internet Gateway provides access to the internet, enabling public-facing EC2 instances to serve web traffic. This is the architecture diagram: "
},
{
	"uri": "/3-network/3.1-vpc_subnets/",
	"title": "VPC and Subnets",
	"tags": [],
	"description": "",
	"content": "Set up files In the subnets folder, we will create three files and name them respectively as main.tf, variables.tf, outputs.tf\nsubnets\r├── main.tf\r├── outputs.tf\r└── variables.tf Variables Firstly, we will define two Availability Zones, VPC CIDR block, 4 Subnets CIDR block in variables.tf:\nvariable \u0026#34;vpc_cidr\u0026#34; {\rtype = string\rdefault = \u0026#34;10.0.0.0/16\u0026#34;\r}\rvariable \u0026#34;first_public_subnet_cidr\u0026#34; {\rtype = string\rdefault = \u0026#34;10.0.1.0/24\u0026#34;\r}\rvariable \u0026#34;second_public_subnet_cidr\u0026#34; {\rtype = string\rdefault = \u0026#34;10.0.3.0/24\u0026#34;\r}\rvariable \u0026#34;first_private_subnet_cidr\u0026#34; {\rtype = string\rdefault = \u0026#34;10.0.2.0/24\u0026#34;\r}\rvariable \u0026#34;second_private_subnet_cidr\u0026#34; {\rtype = string\rdefault = \u0026#34;10.0.4.0/24\u0026#34;\r}\rvariable \u0026#34;first_az\u0026#34; {\rtype = string\rdefault = \u0026#34;us-east-1a\u0026#34;\r}\rvariable \u0026#34;second_az\u0026#34; {\rtype = string\rdefault = \u0026#34;us-east-1b\u0026#34;\r} Main VPC: We create a VPC using resource aws_vpc: resource \u0026#34;aws_vpc\u0026#34; \u0026#34;main\u0026#34; {\rcidr_block = var.vpc_cidr\rtags = {\rName = \u0026#34;workshop-1\u0026#34;\r}\r} Subnets: Here we will create 4 subnets, including 2 public subnets for our EC2 instances and 2 private subnets for RDS subnet group: resource \u0026#34;aws_subnet\u0026#34; \u0026#34;first_public\u0026#34; {\rvpc_id = aws_vpc.main.id\rcidr_block = var.first_public_subnet_cidr\ravailability_zone = var.first_az\rmap_public_ip_on_launch = true\rtags = {\rName = \u0026#34;first_public\u0026#34;\r}\r}\rresource \u0026#34;aws_subnet\u0026#34; \u0026#34;second_public\u0026#34; {\rvpc_id = aws_vpc.main.id\rcidr_block = var.second_public_subnet_cidr\ravailability_zone = var.second_az\rmap_public_ip_on_launch = true\rtags = {\rName = \u0026#34;second_public\u0026#34;\r}\r}\rresource \u0026#34;aws_subnet\u0026#34; \u0026#34;first_private\u0026#34; {\rvpc_id = aws_vpc.main.id\rcidr_block = var.first_private_subnet_cidr\ravailability_zone = var.first_az\rtags = {\rName = \u0026#34;first_private\u0026#34;\r}\r}\rresource \u0026#34;aws_subnet\u0026#34; \u0026#34;second_private\u0026#34; {\rvpc_id = aws_vpc.main.id\rcidr_block = var.second_private_subnet_cidr\ravailability_zone = var.second_az\rtags = {\rName = \u0026#34;second_private\u0026#34;\r}\r} Internet Gateway: In order to make a subnet public, we need an Internet Gateway in this VPC: resource \u0026#34;aws_internet_gateway\u0026#34; \u0026#34;main\u0026#34; {\rvpc_id = aws_vpc.main.id\rtags = {\rName = \u0026#34;workshop-1\u0026#34;\r}\r} Route table: To make our two subnets public, we also need a custom route table that has a route to the upon Internet Gateway and associate it with our two subnets: resource \u0026#34;aws_route_table\u0026#34; \u0026#34;public\u0026#34; {\rvpc_id = aws_vpc.main.id\rroute {\rcidr_block = \u0026#34;0.0.0.0/0\u0026#34;\rgateway_id = aws_internet_gateway.main.id\r}\r}\rresource \u0026#34;aws_route_table_association\u0026#34; \u0026#34;first_public\u0026#34; {\rsubnet_id = aws_subnet.first_public.id\rroute_table_id = aws_route_table.public.id\r}\rresource \u0026#34;aws_route_table_association\u0026#34; \u0026#34;second_public\u0026#34; {\rsubnet_id = aws_subnet.second_public.id\rroute_table_id = aws_route_table.public.id\r} Output This module will output VPC’id, subnets’id so that other modules can reference:\noutput \u0026#34;vpc_id\u0026#34; {\rvalue = aws_vpc.main.id\r}\routput \u0026#34;first_public_subnet_id\u0026#34; {\rvalue = aws_subnet.first_public.id\r}\routput \u0026#34;second_public_subnet_id\u0026#34; {\rvalue = aws_subnet.second_public.id\r}\routput \u0026#34;first_private_subnet_id\u0026#34; {\rvalue = aws_subnet.first_private.id\r}\routput \u0026#34;second_private_subnet_id\u0026#34; {\rvalue = aws_subnet.second_private.id\r} "
},
{
	"uri": "/2-prerequiste/2.2-awscli/",
	"title": "AWS CLI",
	"tags": [],
	"description": "",
	"content": "Configure AWS CLI We will configure basic settings that the AWS CLI uses to interact with AWS, we create a new profile WorkshopUser by Terminal and use that profile to handle create resources in Terraform.\nWe can check how many profiles we have:\n$ aws configure list-profiles Now create WorkshopUser profile:\n$ aws configure --profile WorkshopUser\rAWS Access Key ID [None]: **************UHKK\rAWS Secret Access Key [None]: *************io+dFg5\rDefault region name [None]: ap-southeast-1\rDefault output format [None]: "
},
{
	"uri": "/4-computing-storage/4.2-computing/",
	"title": "Create EC2 instance",
	"tags": [],
	"description": "",
	"content": "Set up files In the instances folder, we will create five files and name them respectively as main.tf, variables.tf, outputs.tf, locals, data.tf\ninstances\r├── data.tf\r├── locals.tf\r├── main.tf\r├── outputs.tf\r└── variables.tf Variables This module will require VPC’s id, security group’s id, two subnets’s ids and database credentials:\nvariable \u0026#34;vpc_id\u0026#34; {\rtype = string\r}\rvariable \u0026#34;security_group_id\u0026#34; {\rtype = string\r}\rvariable \u0026#34;first_public_subnet_id\u0026#34; {\rtype = string\r}\rvariable \u0026#34;second_public_subnet_id\u0026#34; {\rtype = string\r}\rvariable \u0026#34;rds_host\u0026#34; {\rtype = string\r}\rvariable \u0026#34;rds_password\u0026#34; {\rtype = string\r}\rvariable \u0026#34;rds_username\u0026#34; {\rtype = string\r} Data Beside that, we also need to provide information of AMI that EC2 instance would use:\ndata \u0026#34;aws_ami\u0026#34; \u0026#34;web_server\u0026#34; {\rmost_recent = true\rowners = [\u0026#34;amazon\u0026#34;]\rfilter {\rname = \u0026#34;name\u0026#34;\rvalues = [\u0026#34;ubuntu/images/hvm-ssd/ubuntu-jammy-22.04-amd64-*\u0026#34;]\r}\rfilter {\rname = \u0026#34;virtualization-type\u0026#34;\rvalues = [\u0026#34;hvm\u0026#34;]\r}\r} Locals We will create two EC2 instances, their parameter will be stored in a local:\nlocals {\rweb_servers = {\rserver_1 = {\rmachine_type = \u0026#34;t3.micro\u0026#34;\rsubnet_id = var.first_public_subnet_id\r}\rserver_2 = {\rmachine_type = \u0026#34;t3.micro\u0026#34;\rsubnet_id = var.second_public_subnet_id\r}\r}\r} Init script This script will be run after our EC2 instances has been initialized, we will create it on root folder:\n#!/bin/bash\r# Install nodejs, npm\rsudo mkdir -p /etc/apt/keyrings\rcurl -fsSL https://deb.nodesource.com/gpgkey/nodesource-repo.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/nodesource.gpg\rNODE_MAJOR=20\recho \u0026#34;deb [signed-by=/etc/apt/keyrings/nodesource.gpg] https://deb.nodesource.com/node_$NODE_MAJOR.x nodistro main\u0026#34; | sudo tee /etc/apt/sources.list.d/nodesource.list\rsudo apt update\rsudo apt install -y nodejs ## clone source code\rgit clone https://github.com/AWS-First-Cloud-Journey/AWS-FCJ-Management\rcd AWS-FCJ-Management/\r## set up environment variables\rcat \u0026lt;\u0026lt; EOF \u0026gt; .env\rDB_HOST=${rds_endpoint}\rDB_NAME=first_cloud_users\rDB_USER=${rds_username}\rDB_PASS=${rds_password}\rEOF\r## run web application\rsudo npm install -g nodemon\rnpm i\rnpm run start Main Create two EC2 instances:\nresource \u0026#34;aws_instance\u0026#34; \u0026#34;main\u0026#34; {\rfor_each = local.web_servers\rvpc_security_group_ids = [var.security_group_id]\rsubnet_id = each.value.subnet_id\rinstance_type = each.value.machine_type\rami = data.aws_ami.web_server.id\rtags = {\rName = each.key\r}\rroot_block_device {\rvolume_size = 20\rvolume_type = \u0026#34;gp2\u0026#34;\r}\ruser_data = (templatefile(\u0026#34;${path.root}/init.sh.tpl\u0026#34;, {\rrds_endpoint = var.rds_host,\rrds_username = var.rds_username,\rrds_password = var.rds_password\r}))\r} Output This module simply bring out EC2 instances:\noutput \u0026#34;instances\u0026#34; {\rvalue = aws_instance.main\r} "
},
{
	"uri": "/5-alb-route53/5-2-route53/",
	"title": "Create Route53 record",
	"tags": [],
	"description": "",
	"content": "Route 53 is AWS highly scalable and reliable Domain Name System (DNS) web service. It enables you to register domain names, route traffic to resources globally, and manage the DNS records for your domain. Here are some key features and functionalities of Route 53: Domain Registration, DNS Management, Traffic Routing, Health Checks, Integration with AWS Services\nSet up files In dns folder, we create three respectively files, named main.tf, variables.tf, data.tf\ndatabases ├── main.tf ├── data.tf └── variables.tf Data Because I registered a domain(cloudemon.me) from Namecheap and hosted it with Route53 Hosted Zone, I need to import its information:\ndata \u0026#34;aws_route53_zone\u0026#34; \u0026#34;main\u0026#34; { name = \u0026#34;cloudemon.me\u0026#34; } Variables We need a Route53 record so that it will route traffic to our Application Load Balancer, so that this module needs the load balancer’s dns name and zone id:\nvariable \u0026#34;lb_dns_name\u0026#34; { type = string } variable \u0026#34;lb_zone_id\u0026#34; { type = string } Main Just create a Route53 record:\nresource \u0026#34;aws_route53_record\u0026#34; \u0026#34;main\u0026#34; { zone_id = data.aws_route53_zone.main.zone_id name = \u0026#34;web.cloudemon.me\u0026#34; type = \u0026#34;A\u0026#34; alias { name = var.lb_dns_name zone_id = var.lb_zone_id evaluate_target_health = true } } "
},
{
	"uri": "/2-prerequiste/",
	"title": "Preparation ",
	"tags": [],
	"description": "",
	"content": "IAM User An AWS Identity and Access Management (IAM) user is an entity that you create in AWS. The IAM user represents the human user or workload who uses the IAM user to interact with AWS. A user in AWS consists of a name and credentials.\nAWS CLI The AWS Command Line Interface (AWS CLI) is an open source tool from Amazon Web Services (AWS). You can use it to interact with AWS services using commands in your command line shell.\nWith minimal configuration, you can use the AWS CLI to commands that implement functionality equivalent to that provided by the browser-based AWS Management Console.\nTerraform CLI Terraform is an Infrastructure-as-Code tool for building, changing, and versioning infrastructure safely and efficiently. Terraform can manage existing and popular service providers as well as custom in-house solutions.\nContent IAM User AWS CLI Terraform CLI Module Structure "
},
{
	"uri": "/3-network/3.2-security_groups/",
	"title": "Security Groups",
	"tags": [],
	"description": "",
	"content": "Set up files In the security_groups folder, we will create three files and name them respectively as main.tf, variables.tf, outputs.tf\nsecurity_groups\r├── main.tf\r├── outputs.tf\r└── variables.tf Variables In this module, we only need the VPC’id from the subnets module:\nvariable \u0026#34;vpc_id\u0026#34; {\r} Main Security group for Load Balancer: For the Load Balancer, it needs a security group that only accepts traffic from users on port 80. Here we define that with 2 resources: aws_security_group and aws_security_group_rule: resource \u0026#34;aws_security_group\u0026#34; \u0026#34;load_balancer\u0026#34; {\rname = \u0026#34;load-balancer\u0026#34;\rvpc_id = var.vpc_id\rtags = {\rName = \u0026#34;load-balancer\u0026#34;\r}\r}\rresource \u0026#34;aws_security_group_rule\u0026#34; \u0026#34;lb_egress_traffic\u0026#34; {\rtype = \u0026#34;egress\u0026#34;\rfrom_port = 0\rto_port = 0\rprotocol = \u0026#34;-1\u0026#34;\rsecurity_group_id = aws_security_group.load_balancer.id\rcidr_blocks = [\u0026#34;0.0.0.0/0\u0026#34;]\r}\rresource \u0026#34;aws_security_group_rule\u0026#34; \u0026#34;lb_ingress_http\u0026#34; {\rtype = \u0026#34;ingress\u0026#34;\rfrom_port = 80\rto_port = 80\rprotocol = \u0026#34;tcp\u0026#34;\rsecurity_group_id = aws_security_group.load_balancer.id\rcidr_blocks = [\u0026#34;0.0.0.0/0\u0026#34;]\r} Security group for EC2 instance: For the Load Balancer, it needs a security group that only accepts traffic from application load balancer on port 5000. Here we define that with 2 resources: aws_security_group and aws_security_group_rule: resource \u0026#34;aws_security_group\u0026#34; \u0026#34;ec2\u0026#34; {\rname = \u0026#34;api\u0026#34;\rvpc_id = var.vpc_id\rtags = {\rName = \u0026#34;api\u0026#34;\r}\r}\rresource \u0026#34;aws_security_group_rule\u0026#34; \u0026#34;ec2_egress_traffic\u0026#34; {\rtype = \u0026#34;egress\u0026#34;\rfrom_port = 0\rto_port = 0\rprotocol = \u0026#34;-1\u0026#34;\rsecurity_group_id = aws_security_group.ec2.id\rcidr_blocks = [\u0026#34;0.0.0.0/0\u0026#34;]\r}\rresource \u0026#34;aws_security_group_rule\u0026#34; \u0026#34;ec2_ingress_http\u0026#34; {\rtype = \u0026#34;ingress\u0026#34;\rfrom_port = 5000\rto_port = 5000\rprotocol = \u0026#34;tcp\u0026#34;\rsecurity_group_id = aws_security_group.ec2.id\rsource_security_group_id = aws_security_group.load_balancer.id\r} Security group for RDS instance: Next, with the RDS instance, we will allow only traffic from EC2 instances on port 3306: resource \u0026#34;aws_security_group\u0026#34; \u0026#34;rds\u0026#34; {\rtags = {\rName = \u0026#34;rds\u0026#34;\r}\rvpc_id = var.vpc_id\r}\rresource \u0026#34;aws_security_group_rule\u0026#34; \u0026#34;rds_ingress\u0026#34; {\rtype = \u0026#34;ingress\u0026#34;\rfrom_port = 3306\rto_port = 3306\rprotocol = \u0026#34;tcp\u0026#34;\rsecurity_group_id = aws_security_group.rds.id\rsource_security_group_id = aws_security_group.ec2.id\r} Output: Other modules will need all security groups’s id:\noutput \u0026#34;load_balancer_sg_id\u0026#34; {\rvalue = aws_security_group.load_balancer.id\r}\routput \u0026#34;ec2_sg_id\u0026#34; {\rvalue = aws_security_group.ec2.id\r}\routput \u0026#34;rds_sg_id\u0026#34; {\rvalue = aws_security_group.rds.id\r} "
},
{
	"uri": "/3-network/",
	"title": "Networking",
	"tags": [],
	"description": "",
	"content": "In this section we will create Virtual Private Cloud (VPC), including setting up internet gateways, subnets, route tables, security groups:\nContent 3.1. VPC 3.2. Subnets\n"
},
{
	"uri": "/2-prerequiste/2.3-terraformcli/",
	"title": "Terraform CLI",
	"tags": [],
	"description": "",
	"content": "Introduction Terraform provides a command line interface (CLI) that can be called with the terraform command once you’ve installed Terraform onto your system.\nTo view a list of the commands available in your current Terraform version, run terraform with no additional arguments:\nUsage: terraform [global options] \u0026lt;subcommand\u0026gt; [args] The available commands for execution are listed below. The primary workflow commands are given first, followed by less common or more advanced commands. Main commands: init Prepare your working directory for other commands validate Check whether the configuration is valid plan Show changes required by the current configuration apply Create or update infrastructure destroy Destroy previously-created infrastructure All other commands: console Try Terraform expressions at an interactive command prompt fmt Reformat your configuration in the standard style force-unlock Release a stuck lock on the current workspace get Install or upgrade remote Terraform modules graph Generate a Graphviz graph of the steps in an operation import Associate existing infrastructure with a Terraform resource login Obtain and save credentials for a remote host logout Remove locally-stored credentials for a remote host metadata Metadata related commands output Show output values from your root module providers Show the providers required for this configuration refresh Update the state to match remote systems show Show the current state or a saved plan state Advanced state management taint Mark a resource instance as not fully functional untaint Remove the \u0026#39;tainted\u0026#39; state from a resource instance version Show the current Terraform version workspace Workspace management Global options (use these before the subcommand, if any): -chdir=DIR Switch to a different working directory before executing the given subcommand. -help Show this help output, or the help for a specified subcommand. -version An alias for the \u0026#34;version\u0026#34; subcommand. Terraform init The terraform init command initializes your Terraform working directory.\nTerraform validate The terraform validate command runs checks to verify that the Terraform configuration in the working directory is syntactically valid, but does not validate remote services like remote state and provider APIs.\nTerraform plan The terraform plan command creates and execution plan that provides you a preview of the changes that will be made to your infrastructure (ie. which resources will be created, which will be deleted, and which ones will be modified).\nTerraform apply The terraform apply command executes the actions that are proposed from the Terraform plan.\nTerraform destroy The terraform destroy command deletes all remote resources that are managed by the current working directory’s Terraform configuration.\n"
},
{
	"uri": "/4-computing-storage/",
	"title": "Computing and Storage",
	"tags": [],
	"description": "",
	"content": "In this section we will create a Multi-AZ RDS instance and two EC2 following the diagram below: Content: Create a multi-az RDS instance Create two EC2 instances "
},
{
	"uri": "/2-prerequiste/2.4-projectstructure/",
	"title": "Project Structure",
	"tags": [],
	"description": "",
	"content": "Folder structure In this project, we leverage Terraform’s module. Below are six modules for this workshop:\nworkshop-1 ├── databases ├── dns ├── instances ├── load_balancers ├── security_groups └── subnets Inside a module A typical module contains a main.tf, outputs.tf, locals.tf, and variables.tf, data.tf where:\nmain.tf contains the core resources of the module outputs.tf (Optional) contains the outputs of the module variables.tf (Optional) contains the input variables of the module locals.tf (Optional) contain internal variables of the module data.tf (Optional) contain external information Provider We create a provider.tf file in root folder, this is where we configure our profile, region and terraform\u0026rsquo;s version.\nBlock provider: This block declares the AWS provider and specifies its configuration settings. Using ap-southeast-1 (Singapore Region) Your profile: WorkshopUser Block terraform: This block declars the Terraform provider\u0026rsquo;s version for AWS terraform { required_providers { aws = { source = \u0026#34;hashicorp/aws\u0026#34; version = \u0026#34;~\u0026gt; 4.0\u0026#34; } } } provider \u0026#34;aws\u0026#34; { region = \u0026#34;us-east-1\u0026#34; profile = \u0026#34;WorkshopUser\u0026#34; } After configuring the provider and setting up folder structure, we execute the terraform init command to initialize Terraform and prepare the working directory for further operations.\nterraform init "
},
{
	"uri": "/5-alb-route53/",
	"title": "Application Load Balancer and Route53",
	"tags": [],
	"description": "",
	"content": "In this section we will create an Application Load Balancer and a Route53 record following the diagram below: Content Create an Application Load Balancer Create a Route53 record "
},
{
	"uri": "/6-deploying/",
	"title": "Deploying infrastructure",
	"tags": [],
	"description": "",
	"content": "Overview In this part, we will learn how we can use Terraform to provision infrastructure using Terraform CLI and see our result.\nDetails Now, we must create a main.tf file in root directory, it will be where our modules be called. Here are its content: module \u0026#34;subnets\u0026#34; { source = \u0026#34;./subnets\u0026#34; } module \u0026#34;security_groups\u0026#34; { source = \u0026#34;./security_groups\u0026#34; vpc_id = module.subnets.vpc_id } module \u0026#34;databases\u0026#34; { source = \u0026#34;./databases\u0026#34; vpc_id = module.subnets.vpc_id first_subnet_id = module.subnets.first_private_subnet_id second_subnet_id = module.subnets.second_private_subnet_id security_group_id = module.security_groups.rds_sg_id rds_username = jsondecode(file(\u0026#34;${path.root}/secrets.json\u0026#34;))[\u0026#34;DB_USERNAME\u0026#34;] rds_password = jsondecode(file(\u0026#34;${path.root}/secrets.json\u0026#34;))[\u0026#34;DB_PASSWORD\u0026#34;] } module \u0026#34;instances\u0026#34; { source = \u0026#34;./instances\u0026#34; vpc_id = module.subnets.vpc_id security_group_id = module.security_groups.ec2_sg_id first_public_subnet_id = module.subnets.first_public_subnet_id second_public_subnet_id = module.subnets.second_public_subnet_id rds_host = module.databases.rds_host rds_username = jsondecode(file(\u0026#34;${path.root}/secrets.json\u0026#34;))[\u0026#34;DB_USERNAME\u0026#34;] rds_password = jsondecode(file(\u0026#34;${path.root}/secrets.json\u0026#34;))[\u0026#34;DB_PASSWORD\u0026#34;] } module \u0026#34;load_balancer\u0026#34; { source = \u0026#34;./load_balancers\u0026#34; vpc_id = module.subnets.vpc_id security_group_id = module.security_groups.load_balancer_sg_id instances = module.instances.instances subnets = [module.subnets.first_public_subnet_id, module.subnets.second_public_subnet_id] } module \u0026#34;dns\u0026#34; { source = \u0026#34;./dns\u0026#34; lb_dns_name = module.load_balancer.dns_name lb_zone_id = module.load_balancer.zone_id } You need to open the terminal in Visual Studio Code. Click on View and choose Terminal. After opening the terminal, you will notice that we are in the Workshop-1 folder. Now, we need to validate our configuration. Use the following command in the terminal to do so.\nterraform validate You will see the output like Success! The configuration is valid. in the terminal. Apply the configuration now with the terraform apply command. Terraform will print output similar to what is shown below. After you run the command, you will see the output in the terminal like this. In the end, you will see a question like “Enter a Value”. Enter yes so terraform can provision infrastructure. You will see a line Apply complete! Resources: 27 added, 0 changed, 0 destroyed.\nView results\nVPC: Security Groups: Subnets: RDS instance: EC2 instances: Application Load Balancer: Route53 record: Web view: "
},
{
	"uri": "/7-cleanup/",
	"title": "Clean up resources",
	"tags": [],
	"description": "",
	"content": "Delete resources using Terraform Following these steps:\nFirst, open the terminal in Visual Studio Code. Type the following command. terraform destroy After you run the command, you will see the output like this. Enter yes to agree destroying the resources. The terraform destroy command is a convenient way to destroy all remote objects managed by a particular Terraform configuration. You can see that Terraform will delete the resources for us. We don’t need to go on the AWS Management Console and delete each resource.\n(Optional) You can go deleting IAM user.\n"
},
{
	"uri": "/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]